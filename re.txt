匹配规则：
    . :  匹配一个除了换行的任意字符
    []: 匹配字符集中任意一个字符
        [abc#!好] 表示[]中任意一个字符
        [0-9],[a-z],[A-Z] 表示区间内任意一个字符
        [！#？0-9a-z] 混合书写，一般区间表达写在后面
    [^字符集]:匹配除了字符集以外的任意一个字符
    ^:  匹配目标字符串的开头位置（放在匹配开头位置）
    $:  匹配目标字符串的结束位置（放在匹配结尾位置）
    *:  匹配前面的字符出现0次或多次
    +:  匹配前面的字符出现1次或多次
    ?:  匹配前面的字符出现0次或1次
    {n}:匹配前面的字符出现n次
    {m,n}:匹配前面的字符出现m-n次
    \d \D:\d匹配任意数字字符
          \D匹配任意非数字字符
    \w \W:\w匹配普通字符（数字，字母，下划线，汉字）
          \W匹配非普通字符
    \s \S:\s匹配空字符（空格 \r（回车） \n \t \v \f）
          \S匹配非空字符
    \A \Z:\A表示开头位置
          \Z表示结尾位置
    \b \B:\b表示单词边界（指数字字母（汉字）下划线与其他字符的交界位置）
          \B表示非单词边界
    需要转义的特殊符号：
        . * + ? ^ $ [] {} | \
    贪婪模式：默认情况，匹配重复的元字符总是尽可能多的向后匹配内容
            比如： * + ? {m,n}
    非贪婪模式(懒惰模式)：让匹配重复的元字符尽可能少的向后匹配内容
    贪婪模式转化成非贪婪模式：在匹配重复元字符后加‘？’号即可

    子组： （）括号内为一个整体，只能用re.search()
    捕获组： 有名称的子组，（？P<name>...）
    result = re.ssearch(r'(?P<firstName>asd)',"asdasdasd")
    result.group('firstName')
    正则表达式匹配原则：
        正确性：能够正确的匹配出目标字符串
        排他性：除了目标字符串之外尽可能少的匹配其他内容
        全面性：尽可能考虑到目标字符串的所有情况，不遗漏